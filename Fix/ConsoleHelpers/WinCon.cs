// WinCon.cs - Interface module for Windows Console API
// Jim Mischel, 2006/08/25
//
// This module provides the managed-to-unmanaged interface to communicate with
// the Windows Console API.  Full API documentation is available in the Windows SDK
// documentation topic, "Character-Mode Applications," at
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/character_mode_applications.asp
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace Mischel.ConsoleDotNet
{

	#region Console Control Events
	/// <summary>
	/// Control signals received by the console control handler.
	/// </summary>
	public enum ConsoleControlEventType : int
	{
		/// <summary>
		/// A CTRL+C signal was received, either from keyboard input or from a
		/// signal generated by the GenerateConsoleCtrlEvent function.
		/// </summary>
		CtrlC = 0,
		/// <summary>
		/// A CTRL+BREAK signal was received, either from keyboard input or from
		/// a signal generated by GenerateConsoleCtrlEvent.
		/// </summary>
		CtrlBreak = 1,
		/// <summary>
		/// A signal that the system sends to all processes attached to a console
		/// when the user closes the console (either by clicking Close on the console
		/// window's window menu, or by clicking the End Task button command from
		/// Task Manager).
		/// </summary>
		CtrlClose = 2,
		// 3 and 4 are reserved, per WinCon.h
		/// <summary>
		/// A signal that the system sends to all console processes when a user is logging off. 
		/// </summary>
		CtrlLogoff = 5,
		/// <summary>
		/// A signal that the system sends to all console processes when the system is shutting down. 
		/// </summary>
		CtrlShutdown = 6
	}

	/// <summary>
	/// Control event handler delegate.
	/// </summary>
	/// <param name="CtrlType">Control event type.</param>
	/// <returns>Return true to cancel the control event.  A return value of false
	/// will terminate the application and send the event to the next control
	/// handler.</returns>
	public delegate bool ConsoleCtrlHandlerDelegate(ConsoleControlEventType CtrlType);

	#endregion

	#region ConsoleDisplayMode enumeration
	/// <summary>
	/// Console display mode flags used by GetConsoleDisplayMode and SetConsoleDisplayMode.
	/// </summary>
	[Flags]
	public enum ConsoleDisplayMode : int
	{
		/// <summary>
		/// Windowed mode.  The documentation erroneously says that windowed mode is value 2.
		/// </summary>
		Windowed = 0,
		/// <summary>
		/// Fullscreen mode.  The console occupies the entire screen.
		/// </summary>
		Fullscreen = 1,
		/// <summary>
		/// Fullscreen mode communicating directly with the video hardware.
		/// This mode is set after the console has made the transition from
		/// windowed mode to fullscreen mode.  Although this flag can be
		/// returned by GetConsoleDisplayMode, you cannot set the flag when
		/// calling SetConsoleDisplayMode.
		/// </summary>
		FullscreenHardware = 2
	}
	#endregion

	#region ConsoleOutputModeFlags enumeration
	/// <summary>
	/// Flags that affect the console output mode.  Used by SetConsoleMode and
	/// GetConsoleMode.
	/// </summary>
	[Flags]
	public enum ConsoleOutputModeFlags : int
	{
		/// <summary>
		/// Characters written to the console or echoed to the console on read
		/// are examined for ASCII control sequences and the correct action is
		/// performed.  Backspace, tab, bell, carriage return, and linefeed
		/// characters are processed.
		/// </summary>
		Processed = 1,
		/// <summary>
		/// When writing characters or echoing input, the cursor moves to the
		/// beginning of the row when it reaches the end of the current row.
		/// </summary>
		WrapAtEol = 2
	}
	#endregion

	#region ConsoleSelectionFlags enumeration
	/// <summary>
	/// Console selection mode flags used when selecting text in the console.
	/// </summary>
	[Flags]
	public enum ConsoleSelectionFlags
	{
		/// <summary>
		/// There is no current selection
		/// </summary>
		NoSelection = 0,
		/// <summary>
		/// Selection has begun
		/// </summary>
		SelectionInProgress = 1,
		/// <summary>
		/// The selection rectangle is not empty
		/// </summary>
		SelectionNotEmpty = 2,
		/// <summary>
		/// Selecting with the mouse
		/// </summary>
		MouseSelection = 4,
		/// <summary>
		/// Mouse is down
		/// </summary>
		MouseDown = 8
	}
	#endregion

	#region ConsoleInputModeFlags enumeration

	/// <summary>
	/// Console input mode flags used by SetConsoleMode and GetConsoleMode.
	/// </summary>
	[Flags]
	public enum ConsoleInputModeFlags : int
	{
		/// <summary>
		/// Control keys are processed by the system.  Ctrl+C generates a
		/// console control event.  If LineInput is also enabled, backspace,
		/// carriage return, and linefeed characters are processed by the system.
		/// </summary>
		ProcessedInput = 1,
		/// <summary>
		/// Read operations (ReadFile or ReadConsole) return only when a carriage
		/// return character is detected.  If this mode is disabled, the read
		/// functions return when one or more characters are available.
		/// </summary>
		LineInput = 2,
		/// <summary>
		/// Characters read by the ReadFile or ReadConsole function are written to
		/// the active screen buffer as they are read. This mode can be used only
		/// if the LineInput mode is also enabled.
		/// </summary>
		EchoInput = 4,
		/// <summary>
		/// User interactions that change the size of the console screen buffer
		/// are reported in the console's input buffer. 
		/// </summary>
		WindowInput = 8,
		/// <summary>
		/// When enabled, if the mouse pointer is within the borders of the console
		/// window and the window has the keyboard focus, mouse events generated by
		/// mouse movement and button presses are placed in the input buffer.
		/// </summary>
		MouseInput = 16,
		// To set InsertMode or QuickEditMode, be sure
		// to combine with ExtendedFlags
		/// <summary>
		/// When enabled, text entered in a console window will be inserted at the current
		/// cursor location and all text following that location will not be overwritten.
		/// When disabled, all following text will be overwritten. The ExtendedFlags
		/// mode must be included in order to enable this flag.
		/// </summary>
		InsertMode = 32,
		/// <summary>
		/// This flag enables the user to use the mouse to select and edit text. To enable
		/// this option, you must also set the ExtendedFlags flag.
		/// </summary>
		QuickEditMode = 64,
		// ExtendedFlags must be combined with
		// InsertMode and QuickEditMode when setting
		/// <summary>
		/// ExtendedFlags must be enabled in order to enable InsertMode or QuickEditMode.
		/// </summary>
		ExtendedFlags = 128,
		/// <summary>
		/// Unknown
		/// </summary>
		AutoPosition = 256
	};
	#endregion

	#region Coord and SmallRect structures

	/// <summary>
	/// Defines the coordinates of a character cell in a console window.
	/// </summary>
	[StructLayout(LayoutKind.Explicit)]
	public struct Coord
	{
		[FieldOffset(0)] private short x;
		[FieldOffset(2)] private short y;
		/// <summary>
		/// Creates a new instance of the Coord structure.
		/// </summary>
		/// <param name="mx">The column position in the window.</param>
		/// <param name="my">The row position in the window.</param>
		public Coord(short mx, short my)
		{
			x = mx;
			y = my;
		}

		/// <summary>
		/// Gets or sets the column position.
		/// </summary>
		public short X
		{
			get { return x; }
			set { x = value; }
		}

		/// <summary>
		/// Gets or sets the row position.
		/// </summary>
		public short Y
		{
			get { return y; }
			set { y = value; }
		}
	}

	/// <summary>
	/// Defines the coordinates of the upper left and lower right corners of
	/// a rectangle.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class SmallRect
	{
		public short left;
		public short top;
		public short right;
		public short bottom;

		/// <summary>
		/// Creates a new instance of the SmallRect structure.
		/// </summary>
		/// <param name="mLeft">Column position of top left corner.</param>
		/// <param name="mTop">Row position of the top left corner.</param>
		/// <param name="mRight">Column position of the bottom right corner.</param>
		/// <param name="mBottom">Row position of the bottom right corner.</param>
		public SmallRect(short mLeft, short mTop, short mRight, short mBottom)
		{
			left = mLeft;
			top = mTop;
			right = mRight;
			bottom = mBottom;
		}

		/// <summary>
		/// Gets or sets the column position of the top left corner of a rectangle.
		/// </summary>
		public short Left
		{
			get { return left; }
			set { left = value; }
		}

		/// <summary>
		/// Gets or sets the row position of the top left corner of a rectangle.
		/// </summary>
		public short Top
		{
			get { return top; }
			set { top = value; }
		}

		/// <summary>
		/// Gets or sets the column position of the bottom right corner of a rectangle.
		/// </summary>
		public short Right
		{
			get { return right; }
			set { right = value; }
		}

		/// <summary>
		/// Gets or sets the row position of the bottom right corner of a rectangle.
		/// </summary>
		public short Bottom
		{
			get { return bottom; }
			set { bottom = value; }
		}

		/// <summary>
		/// Gets or sets the width of a rectangle.  When setting the width, the
		/// column position of the bottom right corner is adjusted.
		/// </summary>
		public short Width
		{
			get { return (short)(right - left + 1); }
			set { right = (short)(left + value - 1); }
		}

		/// <summary>
		/// Gets or sets the height of a rectangle.  When setting the height, the
		/// row position of the bottom right corner is adjusted.
		/// </summary>
		public short Height
		{
			get { return (short)(bottom - top + 1); }
			set { bottom = (short)(top + value - 1); }
		}
	}
	#endregion

	#region Console input record types

	#region ConsoleControlKeyState enumeration
	/// <summary>
	/// State of the control keys in a KeyEventRecord.
	/// </summary>
	[Flags]
	public enum ConsoleControlKeyState : int
	{
		/// <summary>
		/// Right Alt key is pressed
		/// </summary>
		RightAltPressed = 0x0001,
		/// <summary>
		/// Left Alt key is pressed
		/// </summary>
		LeftAltPressed = 0x0002,
		/// <summary>
		/// Right Ctrl key is pressed
		/// </summary>
		RightCtrlPressed = 0x0004,
		/// <summary>
		/// Left Ctrl key is pressed
		/// </summary>
		LeftCtrlPressed = 0x0008,
		/// <summary>
		/// The shift keys is pressed
		/// </summary>
		ShiftPressed = 0x0010,
		/// <summary>
		/// The number lock light is on
		/// </summary>
		NumLockOn = 0x0020,
		/// <summary>
		/// The scroll lock light is on
		/// </summary>
		ScrollLockOn = 0x0040,
		/// <summary>
		/// The caps lock light is on
		/// </summary>
		CapsLockOn = 0x0080,
		/// <summary>
		/// The key is enhanced
		/// </summary>
		EnhancedKey = 0x0100,
		/// <summary>
		/// DBCS for JPN: SBCS/DBCS mode
		/// </summary>
		NlsDbcsChar = 0x00010000,
		/// <summary>
		/// DBCS for JPN: Alphanumeric mode
		/// </summary>
		NlsAlphanumeric = 0x00000000,
		/// <summary>
		/// DBCS for JPN: Katakana mode
		/// </summary>
		NlsKatakana = 0x00020000,
		/// <summary>
		/// DBCS for JPN: Hiragana mode
		/// </summary>
		NlsHiragana = 0x00040000,
		/// <summary>
		/// DBCS for JPN: Roman/Noroman mode
		/// </summary>
		NlsRoman = 0x00400000,
		/// <summary>
		/// DBCS for JPN: IME conversion
		/// </summary>
		NlsImeConversion = 0x00800000,
		/// <summary>
		/// DBCS for JPN: IME enable/disable
		/// </summary>
		NlsImeDisable = 0x20000000
	}
	#endregion

	#region ConsoleKeyEventInfo structure
	/// <summary>
	/// Reports keyboard events in a console input record.
	/// </summary>
	[StructLayout(LayoutKind.Explicit)]
	public struct ConsoleKeyEventInfo
	{
		[FieldOffset(0)] private int bKeyDown;
		[FieldOffset(4)] private short wRepeatCount;
		[FieldOffset(6)] private short wVirtualKeyCode;
		[FieldOffset(8)] private short wVirtualScanCode;
		[FieldOffset(10)] private char cUnicodeChar;
		[FieldOffset(10)] private short wUnicodeChar;
		[FieldOffset(10)] private byte bAsciiChar;
		[FieldOffset(12)] private int dwControlKeyState;

		/// <summary>
		/// Gets or sets a value indicating whether this is a key down or key up event.
		/// </summary>
		public bool KeyDown
		{
			get { return bKeyDown != 0; }
			set { bKeyDown = (value == true ? (short)1 : (short)0); }
		}

		/// <summary>
		/// Gets or sets a value indicating that a key is being held down.
		/// </summary>
		public short RepeatCount
		{
			get { return (short)wRepeatCount; }
			set { wRepeatCount = value; }
		}

		/// <summary>
		/// Gets or sets a value that identifies the given key in a device-independent manner.
		/// </summary>
		public ConsoleKey VirtualKeyCode
		{
			get { return (ConsoleKey)wVirtualKeyCode; }
			set { wVirtualKeyCode = (short)value; }
		}

		/// <summary>
		/// Gets or sets the hardware-dependent virtual scan code.
		/// </summary>
		public short VirtualScanCode
		{
			get { return wVirtualScanCode; }
			set { wVirtualScanCode = value; }
		}

		/// <summary>
		/// Gets or sets the Unicode character for this key event.
		/// </summary>
		public char UnicodeChar
		{
			get { return cUnicodeChar; }
			set { cUnicodeChar = value; }
		}

		/// <summary>
		/// Gets or sets the ASCII key for this key event.
		/// </summary>
		public byte AsciiChar
		{
			get { return bAsciiChar; }
			set { bAsciiChar = value; }
		}

		/// <summary>
		/// Gets or sets a value specifying the control key state for this key event.
		/// </summary>
		public ConsoleControlKeyState ControlKeyState
		{
			get { return (ConsoleControlKeyState)dwControlKeyState; }
			set { dwControlKeyState = (int)value; }
		}
	}
	#endregion

	#region ConsoleMouseButtonState enumeration
	/// <summary>
	/// A flags enumeration that expresses the state of the mouse buttons.
	/// </summary>
	[Flags]
	public enum ConsoleMouseButtonState : int
	{
		/// <summary>
		/// The leftmost mouse button.
		/// </summary>
		FromLeft1stButtonPressed = 1,
		/// <summary>
		/// The rightmost mouse button.
		/// </summary>
		RightMostButtonPressed = 2,
		/// <summary>
		/// The second button from the left
		/// </summary>
		FromLeft2ndMouseButtonPressed = 4,
		/// <summary>
		/// The third button from the left
		/// </summary>
		FromLeft3rdMouseButtonPressed = 8,
		/// <summary>
		/// The fourth button from the left.
		/// </summary>
		FromLeft4thMouseButtonPressed = 16,
		/// <summary>
		/// For mouse wheel events, if this flag is set,
		/// the wheel was scrolled down.  If cleared,
		/// the wheel was scrolled up.
		/// This is not officially documented.
		/// </summary>
		ScrollDown = unchecked((int)0xFF000000)
	}
	#endregion

	#region ConsoleMouseEventType enumeration
	/// <summary>
	/// Type of mouse event.
	/// </summary>
	[Flags]
	public enum ConsoleMouseEventType
	{
		/// <summary>
		/// A mouse button was pressed or released
		/// </summary>
		MouseButton = 0,
		/// <summary>
		/// A change in mouse position occurred
		/// </summary>
		MouseMoved = 1,
		/// <summary>
		/// The second click of a double-click operation occurred.
		/// </summary>
		DoubleClick = 2,
		/// <summary>
		/// The vertical mouse wheel was rolled.
		/// </summary>
		MouseWheeled = 4,
		/// <summary>
		/// The horizontal mouse wheel was rolled.
		/// </summary>
		MouseHWheeled = 8
	}
	#endregion

	#region ConsoleMouseEventInfo structure

	/// <summary>
	/// Reports a mouse event in a console input record.
	/// </summary>
	[StructLayout(LayoutKind.Explicit)]
	public struct ConsoleMouseEventInfo
	{
		[FieldOffset(0)] private Coord dwMousePosition;
		[FieldOffset(4)] private int dwButtonState;
		[FieldOffset(8)] private int dwControlKeyState;
		[FieldOffset(12)] private int dwEventFlags;

		/// <summary>
		/// Gets or sets a value indicating the current mouse position.
		/// </summary>
		public Coord MousePosition
		{
			get { return dwMousePosition; }
			set { dwMousePosition = value; }
		}

		/// <summary>
		/// Gets or sets a value indicating the state of the mouse buttons.
		/// </summary>
		public ConsoleMouseButtonState ButtonState
		{
			get { return (ConsoleMouseButtonState)dwButtonState; }
			set { dwButtonState = (int)value; }
		}

		/// <summary>
		/// Gets or sets a value indicating the state of the keyboard control keys.
		/// </summary>
		public ConsoleControlKeyState ControlKeyState
		{
			get { return (ConsoleControlKeyState)dwControlKeyState; }
			set { dwControlKeyState = (int)value; }
		}

		/// <summary>
		/// Gets or sets a value indicating the type of mouse event.
		/// </summary>
		public ConsoleMouseEventType EventFlags
		{
			get { return (ConsoleMouseEventType)dwEventFlags; }
			set { dwEventFlags = (int)value; }
		}
	}
	#endregion

	#region ConsoleWindowBufferSizeEventInfo structure
	/// <summary>
	/// Reports window buffer sizing events in a console input record.
	/// </summary>
	[StructLayout(LayoutKind.Explicit)]
	public struct ConsoleWindowBufferSizeEventInfo
	{
		[FieldOffset(0)]
		private Coord dwSize;

		/// <summary>
		/// Gets or sets a value indicating the size of the screen buffer,
		/// in character cell columns and rows.
		/// </summary>
		public Coord Size
		{
			get { return dwSize; }
			set { dwSize = value; }
		}
	}
	#endregion

	#region ConsoleMenuEventInfo structure
	/// <summary>
	/// Reports menu events in a console input record.
	/// Use of this event type is not documented.
	/// </summary>
	[StructLayout(LayoutKind.Explicit)]
	public struct ConsoleMenuEventInfo
	{
		[FieldOffset(0)]
		private int dwCommandId;

		/// <summary>
		/// The id of the menu command.  Possible values are undocumented.
		/// </summary>
		public int CommandId
		{
			get { return dwCommandId; }
			set { dwCommandId = value; }
		}
	}
	#endregion

	#region ConsoleFocusEventInfo structure
	/// <summary>
	/// Reports focus events in a console input record.
	/// Use of this event type is not documented.
	/// </summary>
	[StructLayout(LayoutKind.Explicit)]
	public struct ConsoleFocusEventInfo
	{
		[FieldOffset(0)]
		private uint bSetFocus;

		/// <summary>
		/// Gets or sets a value indicating whether focus is gained or lost.
		/// This value is not documented.
		/// </summary>
		public bool SetFocus
		{
			get { return (bSetFocus != 0); }
			set { bSetFocus = Convert.ToUInt32(value); }
		}
	}
	#endregion

	#region ConsoleInputEventType enumeration
	/// <summary>
	/// Console input event types.
	/// </summary>
	public enum ConsoleInputEventType : short
	{
		KeyEvent = 1,
		MouseEvent = 2,
		WindowBufferSizeEvent = 4,
		MenuEvent = 8,
		FocusEvent = 16
	}
	#endregion

	#region ConsoleInputEventInfo structure

	/// <summary>
	/// Used to report events in the console input buffer.
	/// </summary>
	[StructLayout(LayoutKind.Explicit)]
	public struct ConsoleInputEventInfo
	{
		[FieldOffset(0)] private ConsoleInputEventType evType;
		// NOTE:  Careful here.  Structure packing aligns the
		// Event union (see WinCon.h) on a 4-byte boundary.
		/// <summary>
		/// Key event information if this is a keyboard event.
		/// </summary>
		[FieldOffset(4)] public ConsoleKeyEventInfo KeyEvent;
		/// <summary>
		/// Mouse event information if this is a mouse event.
		/// </summary>
		[FieldOffset(4)] public ConsoleMouseEventInfo MouseEvent;
		/// <summary>
		/// Window buffer size information if this is a window buffer size event.
		/// </summary>
		[FieldOffset(4)] public ConsoleWindowBufferSizeEventInfo WindowBufferSizeEvent;
		/// <summary>
		/// Menu event information if this is a menu event.
		/// </summary>
		[FieldOffset(4)] public ConsoleMenuEventInfo MenuEvent;
		/// <summary>
		/// Focus event information if this is a focus event.
		/// </summary>
		[FieldOffset(4)] public ConsoleFocusEventInfo FocusEvent;

		/// <summary>
		/// Gets or sets a value that specifies the type of event.
		/// </summary>
		public ConsoleInputEventType EventType
		{
			get { return evType; }
			set { evType = value; }
		}
	}
	#endregion

	#endregion

	#region ConsoleCharAttribute structure

	/// <summary>
	/// Helper class that simplifies working with foreground and background colors.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct ConsoleCharAttribute
	{
		private short attr;

		/// <summary>
		/// Creates a new instance of the ConsoleCharAttribute structure
		/// </summary>
		/// <param name="fg">The foreground color.</param>
		/// <param name="bg">The background color.</param>
		public ConsoleCharAttribute(ConsoleColor fg, ConsoleColor bg)
		{
			attr = (short)(((ushort)bg << 4) | (ushort)fg);
		}

		/// <summary>
		/// Creates a new instance of the ConsoleCharAttribute structure.
		/// </summary>
		/// <param name="wAttr">The combined foreground/background attribute.</param>
		public ConsoleCharAttribute(short wAttr)
		{
			attr = wAttr;
		}

		/// <summary>
		/// Gets or sets the foreground color attribute.
		/// </summary>
		public ConsoleColor Foreground
		{
			get { return (ConsoleColor)(attr & 0x0f); }
			set { attr = (short)((attr & 0xfff0) | (ushort)value); }
		}

		/// <summary>
		/// Gets or sets the background color attribute.
		/// </summary>
		public ConsoleColor Background
		{
			get { return (ConsoleColor)((attr >> 4) & 0x0f); }
			set { attr = (short)((attr & 0xff0f) | ((ushort)value << 4)); }
		}

		/// <summary>
		/// Gets or sets the attribute (combined foreground/background color).
		/// </summary>
		public short Attribute
		{
			get { return attr; }
			set { attr = value; }
		}
	}
	#endregion

	#region ConsoleCharInfo structure

	/// <summary>
	/// Specifies a Unicode or ASCII character and its attributes.
	/// </summary>
	[StructLayout(LayoutKind.Explicit)]
	public struct ConsoleCharInfo
	{
		[FieldOffset(0)] private char cUnicodeChar;
		[FieldOffset(0)] private byte bAsciiChar;
		[FieldOffset(2)] private ConsoleCharAttribute attr;

		/// <summary>
		/// Creates a new instance of the ConsoleCharInfo structure.
		/// </summary>
		/// <param name="uChar">The Unicode character.</param>
		/// <param name="attr">Character attributes.</param>
		public ConsoleCharInfo(char uChar, ConsoleCharAttribute attr)
		{
			bAsciiChar = 0;
			cUnicodeChar = uChar;
			this.attr = attr;
		}

		/// <summary>
		/// Creates a new instance of the ConsoleCharInfo structure.
		/// </summary>
		/// <param name="aChar">The ASCII character.</param>
		/// <param name="attr">Character attributes.</param>
		public ConsoleCharInfo(byte aChar, ConsoleCharAttribute attr)
		{
			cUnicodeChar = '\x0';
			bAsciiChar = aChar;
			this.attr = attr;
		}

		/// <summary>
		/// Gets or sets the Unicode character represented by this ConsoleCharInfo structure.
		/// </summary>
		public char UnicodeChar
		{
			get { return cUnicodeChar; }
			set { cUnicodeChar = value; }
		}

		/// <summary>
		/// Gets or sets the ASCII character represented by this ConsoleCharInfo structure.
		/// </summary>
		public byte AsciiChar
		{
			get { return bAsciiChar; }
			set { bAsciiChar = value; }
		}

		/// <summary>
		/// Gets or sets the attributes for this character.
		/// </summary>
		public ConsoleCharAttribute Attribute
		{
			get { return attr; }
			set { attr = value; }
		}

		/// <summary>
		/// Gets or sets the foreground color attribute.
		/// </summary>
		public ConsoleColor Foreground
		{
			get { return attr.Foreground; }
			set { attr.Foreground = value; }
		}

		/// <summary>
		/// Gets or sets the background color attribute.
		/// </summary>
		public ConsoleColor Background
		{
			get { return attr.Background; }
			set { attr.Background = value; }
		}
	}
	#endregion

	#region ConsoleCursorInfo class
	/// <summary>
	/// Contains information about the console cursor.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ConsoleCursorInfo
	{
		private int dwSize;
		private bool bVisible;

		/// <summary>
		/// Creates a new instance of the ConsoleCursorInfo class.
		/// The cursor is initially visible and size is set to 100%.
		/// </summary>
		public ConsoleCursorInfo()
		{
			dwSize = 100;
			bVisible = true;
		}

		/// <summary>
		/// Creates a new instance of the ConsoleCursorInfo class.
		/// </summary>
		/// <param name="vis">Visible flag.  Set to true to make the cursor visible.</param>
		/// <param name="size">Percentage (from 1 to 100) of the character cell that is 
		/// filled by the cursor.</param>
		public ConsoleCursorInfo(bool vis, int size)
		{
			dwSize = size;
			bVisible = vis;
		}

		/// <summary>
		/// Gets or sets a value indicating whether the cursor is visible.
		/// </summary>
		public bool Visible
		{
			get { return bVisible; }
			set { bVisible = value; }
		}

		/// <summary>
		/// Gets or sets a value that indicates the percentabel (from 1 to 100) of the
		/// character cell that is filled by the cursor.
		/// </summary>
		public int Size
		{
			get { return dwSize; }
			set { dwSize = value; }
		}
	}
	#endregion

	#region ConsoleScreenBufferInfo class

	/// <summary>
	/// Contains information about a console screen buffer.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ConsoleScreenBufferInfo
	{
		public Coord dwSize;
		public Coord dwCursorPosition;
		public short wAttributes;
		[MarshalAs(UnmanagedType.Struct)] public SmallRect srWindow;
		public Coord dwMaximumWindowSize;
	}
	#endregion

	#region ConsoleSelectionInfo class

	/// <summary>
	/// Contains information for a console selection.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ConsoleSelectionInfo
	{
		public int dwFlags;
		public Coord dwSelectionAnchor;
		[MarshalAs(UnmanagedType.Struct)] public SmallRect srSelection;
	}
	#endregion

	#region ConsoleFontInfo class
	/// <summary>
	/// Contains information about a console font.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ConsoleFontInfo
	{
		public int nFont;
		public Coord dwFontSize;
	}
	#endregion

	#region Console API functions and constants
	/// <summary>
	/// Windows Console API definitions.
	/// </summary>
	public sealed class WinCon
	{
		// Attributes flags:
		public const int FOREGROUND_BLUE = 0x0001; // text color contains blue.
		public const int FOREGROUND_GREEN = 0x0002; // text color contains green.
		public const int FOREGROUND_RED = 0x0004; // text color contains red.
		public const int FOREGROUND_INTENSITY = 0x0008; // text color is intensified.
		public const int BACKGROUND_BLUE = 0x0010; // background color contains blue.
		public const int BACKGROUND_GREEN = 0x0020; // background color contains green.
		public const int BACKGROUND_RED = 0x0040; // background color contains red.
		public const int BACKGROUND_INTENSITY = 0x0080; // background color is intensified.
		public const int COMMON_LVB_LEADING_BYTE = 0x0100; // Leading Byte of DBCS
		public const int COMMON_LVB_TRAILING_BYTE = 0x0200; // Trailing Byte of DBCS
		public const int COMMON_LVB_GRID_HORIZONTAL = 0x0400; // DBCS: Grid attribute: top horizontal.
		public const int COMMON_LVB_GRID_LVERTICAL = 0x0800; // DBCS: Grid attribute: left vertical.
		public const int COMMON_LVB_GRID_RVERTICAL = 0x1000; // DBCS: Grid attribute: right vertical.
		public const int COMMON_LVB_REVERSE_VIDEO = 0x4000; // DBCS: Reverse fore/back ground attribute.
		public const int COMMON_LVB_UNDERSCORE = 0x8000; // DBCS: Underscore.
		public const int COMMON_LVB_SBCSDBCS = 0x0300; // SBCS or DBCS flag.

		public const int ATTACH_PARENT_PROCESS = -1;

		public const int CONSOLE_TEXTMODE_BUFFER = 1;

		public const int STD_INPUT_HANDLE = -10;
		public const int STD_OUTPUT_HANDLE = -11;
		public const int STD_ERROR_HANDLE = -12;

		// *******************************************************
		// * API Definitions
		// *******************************************************

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool AddConsoleAlias(
			string Source,
			string Target,
			string ExeName);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool AllocConsole();

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool AttachConsole(int dwProcessId);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr CreateConsoleScreenBuffer(
			int dwDesiredAccess,
			int dwShareMode,
			[In, Out][MarshalAs(UnmanagedType.LPStruct)] SecurityAttributes lpSecurityAttributes,
			int dwFlags,
			IntPtr lpScreenBufferData);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool FillConsoleOutputAttribute(
			IntPtr hConsoleOutput,
			ConsoleCharAttribute wAttribute,
			int nLength,
			Coord dwWriteCoord,
			ref int lpNumberOfAttrsWritten);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool FillConsoleOutputCharacter(
			IntPtr hConsoleOutput,
			char cCharacter,
			int nLength,
			Coord dwWriteCoord,
			ref int lpNumberOfCharsWritten);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool FlushConsoleInputBuffer(IntPtr hConsoleInput);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool FreeConsole();

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool GenerateConsoleCtrlEvent(
			int ctrlEvent,
			int dwProcessGroupId);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern int GetConsoleAlias(
			string lpSource,
			[Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] char[] lpTargetBuffer,
			int TargetBufferLength,
			string lpExeName);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern int GetConsoleAliases(
			[Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] char[] lpAliasBuffer,
			int AliasBufferLength,
			string lpExeName);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern int GetConsoleAliasesLength(string lpExeName);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern int GetConsoleAliasExes(
			[In, Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] char[] lpExeNameBuffer,
			int ExeNameBufferLength);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern int GetConsoleAliasExesLength();

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern int GetConsoleCP();

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool GetConsoleCursorInfo(
			IntPtr hConsoleOutput,
			[Out][MarshalAs(UnmanagedType.LPStruct)] ConsoleCursorInfo lpConsoleCursorInfo);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool GetConsoleDisplayMode(ref int lpModeFlags);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern Coord GetConsoleFontSize(
			IntPtr hConsoleOutput,
			int nFont);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool GetConsoleMode(
			IntPtr hConsoleHandle,
			ref int lpMode);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern int GetConsoleOutputCP();

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern int GetConsoleProcessList(
			[In, Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] lpdwProcessList,
			int dwProcessCount);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool GetConsoleScreenBufferInfo(
			IntPtr hConsoleOutput,
			[In, Out][MarshalAs(UnmanagedType.LPStruct)] ConsoleScreenBufferInfo lpConsoleScreenBufferInfo);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool GetConsoleSelectionInfo(
			[In, Out][MarshalAs(UnmanagedType.LPStruct)] ConsoleSelectionInfo lpConsoleSelectionInfo);

		[DllImport("kernel32.dll", SetLastError = true)]
		// documentation says that this should work with Unicode.
		// It doesn't appear to.
		public static extern int GetConsoleTitle(
			[In, Out][MarshalAs(UnmanagedType.LPStr, SizeParamIndex = 1)] StringBuilder lpConsoleTitle,
			int nSize);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr GetConsoleWindow();

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool GetCurrentConsoleFont(
			IntPtr hConsoleOutput,
			bool bMaximumWindow,
			[Out][MarshalAs(UnmanagedType.LPStruct)] ConsoleFontInfo lpConsoleCurrentFont);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern Coord GetLargestConsoleWindowSize(IntPtr hConsoleOutput);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool GetNumberOfConsoleInputEvents(
			IntPtr hConsoleInput,
			ref int lpcNumberOfEvents);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool GetNumberOfConsoleMouseButtons(ref int lpNumberOfMouseButtons);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr GetStdHandle(int nStdHandle);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool PeekConsoleInput(
			IntPtr hConsoleInput,
			[Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ConsoleInputEventInfo[] lpBuffer,
			int nLength,
			ref int lpNumberOfEventsRead);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool ReadConsole(
			IntPtr hConsoleInput,
			[Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] char[] lpBuffer,
			int nNumberOfCharsToRead,
			ref int lpNumberOfCharsRead,
			IntPtr lpReserved);  // must be null (IntPtr.Zero)

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool ReadConsoleInput(
			IntPtr hConsoleInput,
			[Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ConsoleInputEventInfo[] lpBuffer,
			int nLength,
			ref int lpNumberOfEventsRead);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool ReadConsoleOutput(
			IntPtr hConsoleOutput,
			[Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ConsoleCharInfo[,] lpBuffer,
			Coord dwBufferSize,
			Coord dwBufferCoord,
			[In, Out][MarshalAs(UnmanagedType.LPStruct)] SmallRect lpReadRegion);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool ReadConsoleOutputAttribute(
			IntPtr hConsoleOutput,
			[Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ConsoleCharAttribute[] lpAttribute,
			int nLength,
			Coord dwReadCoord,
			ref int lpNumberOfAttrsRead);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool ReadConsoleOutputCharacter(
			IntPtr hConsoleOutput,
			[Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] char[] lpCharacter,
			int nLength,
			Coord dwReadCoord,
			ref int lpNumberOfCharsRead);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool ScrollConsoleScreenBuffer(
			IntPtr hConsoleOutput,
			[In][MarshalAs(UnmanagedType.LPStruct)] SmallRect lpScrollRectangle,
			[In][MarshalAs(UnmanagedType.LPStruct)] SmallRect lpClipRectangle,
			Coord dwDestinationOrigin,
			ref ConsoleCharInfo lpFill);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleActiveScreenBuffer(IntPtr hConsoleOutput);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleCP(int wCodePageID);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleCtrlHandler(
			ConsoleCtrlHandlerDelegate HandlerRoutine,
			bool Add);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleCursorInfo(
			IntPtr hConsoleOutput,
			[In][MarshalAs(UnmanagedType.LPStruct)] ConsoleCursorInfo lpConsoleCursorInfo);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleCursorPosition(
			IntPtr hConsoleOutput,
			Coord dwCursorPosition);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleDisplayMode(
			IntPtr hConsoleOutput,
			int dwFlags,
			ref Coord lpNewScreenBufferDimensions);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleMode(
			IntPtr hConsoleHandle,
			int ioMode);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleOutputCP(int wCodePageID);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleScreenBufferSize(
			IntPtr hConsoleOutput,
			Coord dwSize);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleTextAttribute(
			IntPtr hConsoleOutput,
			ConsoleCharAttribute attr);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleTitle(string lpConsoleTitle);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetConsoleWindowInfo(
			IntPtr hConsoleOutput,
			bool bAbsolute,
			[In][MarshalAs(UnmanagedType.LPStruct)] SmallRect lpConsoleWindow);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetStdHandle(
			int nStdHandle,
			IntPtr hHandle);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool WriteConsole(
			IntPtr hConsoleOutput,
			[In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] char[] lpBuffer,
			int NumberOfCharsToWrite,
			ref int NumberOfCharsWritten,
			IntPtr reserved);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool WriteConsoleInput(
			IntPtr hConsoleInput,
			[In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ConsoleInputEventInfo[] lpBuffer,
			int nLength,
			ref int lpNumberOfEventsWritten);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool WriteConsoleOutput(
			IntPtr hConsoleOutput,
			[In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ConsoleCharInfo[,] lpBuffer,
			Coord dwBufferSize,
			Coord dwBufferCoord,
			[In, Out][MarshalAs(UnmanagedType.LPStruct)] SmallRect lpWriteRegion);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool WriteConsoleOutputAttribute(
			IntPtr hConsoleOutput,
			[In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ConsoleCharAttribute[] lpAttribute,
			int nLength,
			Coord dwWriteCoord,
			ref int lpNumberOfAttrsWritten);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool WriteConsoleOutputCharacter(
			IntPtr hConsoleOutput,
			[In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] char[] lpCharacter,
			int nLength,
			Coord dwWriteCoord,
			ref int lpNumberOfCharsWritten);

		private WinCon()
		{
			// private constructor prevents instantiation
		}
	}
	#endregion
}
